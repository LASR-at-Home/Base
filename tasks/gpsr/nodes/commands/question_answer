#!/usr/bin/env python3
import rospy
import argparse
import smach
from lasr_voice import Voice
from lasr_skills.xml_question_answer import XmlQuestionAnswer
from gpsr.states.get_question import GetQuestion


class QuestionAnswerStateMachine(smach.StateMachine):
    def __init__(self, input_data: dict):
        smach.StateMachine.__init__(
            self,
            outcomes=["succeeded", "failed"],
            output_keys=["closest_answers"],
        )
        self.userdata.k = input_data["k"]
        self.userdata.index_path = input_data["index_path"]
        self.userdata.txt_path = input_data["txt_path"]
        self.userdata.xml_path = input_data["xml_path"]
        print(self.userdata)

        with self:
            smach.StateMachine.add(
                "GET_QUESTION",
                GetQuestion(),
                transitions={"succeeded": "XML_QUESTION_ANSWER", "failed": "failed"},
                remapping={"question": "query_sentence"},
            )
            smach.StateMachine.add(
                "XML_QUESTION_ANSWER",
                XmlQuestionAnswer(),
                transitions={"succeeded": "succeeded", "failed": "GET_QUESTION"},
                remapping={
                    "query_sentence": "query_sentence",
                    "k": "k",
                    "index_path": "index_path",
                    "txt_path": "txt_path",
                    "xml_path": "xml_path",
                    "closest_answers": "closest_answers",
                },
            )


def parse_args() -> dict:
    parser = argparse.ArgumentParser(description="GPSR Question Answer")
    parser.add_argument(
        "--k",
        type=int,
        help="The number of closest answers to return",
        required=True,
    )
    parser.add_argument(
        "--index_path",
        type=str,
        help="The path to the index file that is populated with the sentences embeddings of the questions",
        required=True,
    )
    parser.add_argument(
        "--txt_path",
        type=str,
        help="The path to the txt file containing a list of questions.",
        required=True,
    )
    parser.add_argument(
        "--xml_path",
        type=str,
        help="The path to the xml file containing question/answer pairs",
        required=True,
    )
    args, _ = parser.parse_known_args()
    args.k = int(args.k)
    return vars(args)


if __name__ == "__main__":
    rospy.init_node("gpsr_question_answer")
    args: dict = parse_args()
    while not rospy.is_shutdown():
        q_a_sm = QuestionAnswerStateMachine(args)
        outcome = q_a_sm.execute()
        voice = Voice()
        if outcome == "succeeded":
            rospy.loginfo(f"Closest Answers: {q_a_sm.userdata.closest_answers}")
            voice.sync_tts(
                f"The answer to your question is: {q_a_sm.userdata.closest_answers[0]}"
            )
        else:
            rospy.logerr("Question Answer State Machine failed")
            voice.sync_tts(f"Sorry, I wasn't able to find an answer to your question")

    rospy.spin()
