#!/usr/bin/env python3

import rospy
import actionlib

from qualification.msg import GuideAction, GuideResult
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from pal_interaction_msgs.msg import TtsGoal, TtsAction
from actionlib import SimpleActionClient
from geometry_msgs.msg import Pose, Point, Quaternion
from unsafe_traversal.srv import LaserDist


class Guide:

    KB = {
        "lab": {
            "pose": Pose(
                position=Point(2.61, 1.33, 0.0),
                orientation=Quaternion(0.0, 0.0, 0.77, 0.63),
            ),
            "edges": {
                "corridor": Pose(
                    position=Point(4.27, 5.80, 0.0),
                    orientation=Quaternion(0.0, 0.0, -0.89, 0.45),
                )
            },
        },
        "corridor": {
            "pose": Pose(
                position=Point(4.35, 11.12, 0.0),
                orientation=Quaternion(0.0, 0.0, 0.28, 0.96),
            ),
            "edges": {
                "lab": Pose(
                    position=Point(4.19, 8.66, 0.0),
                    orientation=Quaternion(0.0, 0.0, -0.55, 0.81),
                ),
                "kitchen": None,
            },
        },
        "kitchen": {
            "pose": Pose(
                position=Point(10.51, 26.60, 0.0),
                orientation=Quaternion(0.0, 0.0, -0.82, 0.56),
            ),
            "edges": {"corridor": None},
        },
    }

    def __init__(self):

        self.move_base = SimpleActionClient("move_base", MoveBaseAction)
        self.move_base.wait_for_server()
        self.tts = SimpleActionClient("/tts", TtsAction)
        self.tts.wait_for_server()
        self.laser_dist = rospy.ServiceProxy(
            "/unsafe_traversal/laser_dist_checker", LaserDist
        )
        self.laser_dist.wait_for_service()
        self._action_server = actionlib.SimpleActionServer(
            "guide",
            GuideAction,
            execute_cb=self.execute_cb,
            auto_start=False,
        )

        self._action_server.start()
        print(self.KB)

    def bfs(self, a, b):
        queue = []
        queue.append([a])
        while queue:
            path = queue.pop(0)
            node = path[-1]
            if node == b:
                return path

            for adj in self.KB[node]["edges"].keys():
                new_path = list(path)
                new_path.append(adj)
                queue.append(new_path)

    def check_for_door(self):
        return self.laser_dist().dist < 2.0

    def execute_cb(self, goal):
        rospy.loginfo(goal)
        tts_goal = TtsGoal()
        tts_goal.rawtext.lang_id = "en_GB"
        tts_goal.rawtext.text = (
            f"{goal.guidee}, I will guide you to the {goal.B}. Please follow me."
        )
        self.tts.send_goal_and_wait(tts_goal)

        poses = []
        path = self.bfs(goal.A, goal.B)
        rospy.loginfo(path)
        for u, v in zip(list(path), list(path)[1:]):
            if self.KB[u]["edges"][v] is not None:
                u_pose = self.KB[u]["edges"][v]
                poses.append((u_pose, True))
                v_pose = self.KB[v]["edges"][u]
                # v_pose.orientation = u_pose.orientation
                poses.append((v_pose, False))
        poses.append((self.KB[goal.B]["pose"], False))

        for pose, could_be_closed in poses:
            move_base_goal = MoveBaseGoal()
            move_base_goal.target_pose.header.stamp = rospy.Time.now()
            move_base_goal.target_pose.header.frame_id = "map"
            move_base_goal.target_pose.pose = pose

            self.move_base.send_goal_and_wait(move_base_goal)
            # TODO: check for failure

            if could_be_closed:
                tts_goal.rawtext.text = (
                    f"{goal.guidee}, could you please get the door for me?"
                )
                self.tts.send_goal_and_wait(tts_goal)
                door_closed = self.check_for_door()
                counter = 1
                while door_closed:
                    if counter % 5 == 0:
                        tts_goal.rawtext.text = f"{goal.guidee}, I see the door is still closed, could you please open it?"
                        self.tts.send_goal_and_wait(tts_goal)
                    rospy.sleep(2)
                    door_closed = self.check_for_door()
                    counter += 1
                # assume it is closed, ask for it to be opened
        tts_goal.rawtext.text = f"We have arrived in the {goal.B}"
        self.tts.send_goal_and_wait(tts_goal)
        self._action_server.set_succeeded(GuideResult())


if __name__ == "__main__":
    rospy.init_node("guide")
    Guide()
    rospy.spin()
