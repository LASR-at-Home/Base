from lasr_vision_msgs.srv import TorchFaceFeatureDetection, TorchFaceFeatureDetectionRequest, TorchFaceFeatureDetectionResponse
from lasr_vision_msgs.msg import FeatureWithColour, ColourPrediction
from sensor_msgs.msg import Image
from colour_estimation import closest_colours, RGB_COLOURS, RGB_HAIR_COLOURS
from cv2_img import msg_to_cv2_img

from PIL import Image as PillowImage

import numpy as np
import torch
import rospy
import lasr_vision_torch
import torch.nn.functional as F

model = lasr_vision_torch.load_face_classifier_model()


def binary_erosion_dilation(tensor, thresholds, erosion_iterations=1, dilation_iterations=1):
    """
    Apply binary threshold, followed by erosion and dilation to a tensor.

    :param tensor: Input tensor (N, C, H, W)
    :param thresholds: List of threshold values for each channel
    :param erosion_iterations: Number of erosion iterations
    :param dilation_iterations: Number of dilation iterations
    :return: Processed tensor
    """

    # Check if the length of thresholds matches the number of channels
    if len(thresholds) != tensor.size(1):
        raise ValueError(
            "Length of thresholds must match the number of channels")

    # Binary thresholding
    for i, threshold in enumerate(thresholds):
        tensor[:, i] = (tensor[:, i] > threshold/2).float() / 4
        tensor[:, i] += (tensor[:, i] > threshold).float()
        tensor[:, i] /= max(tensor[:, i].clone())

    # Define the 3x3 kernel for erosion and dilation
    kernel = torch.tensor([[1, 1, 1],
                           [1, 1, 1],
                           [1, 1, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)

    # Replicate the kernel for each channel
    kernel = kernel.repeat(tensor.size(1), 1, 1, 1).to(tensor.device)

    # Erosion
    for _ in range(erosion_iterations):
        # 3x3 convolution with groups
        tensor = F.conv2d(tensor, kernel, padding=1, groups=tensor.size(1))
        tensor = (tensor == 9).float()  # Check if all neighboring pixels are 1

    # Dilation
    for _ in range(dilation_iterations):
        # 3x3 convolution with groups
        tensor_dilated = F.conv2d(
            tensor, kernel, padding=1, groups=tensor.size(1))
        # Combine the original and dilated tensors
        tensor = torch.clamp(tensor + tensor_dilated, 0, 1)

    return tensor


def median_color_float(rgb_image: torch.Tensor, mask: torch.Tensor) -> torch.Tensor:
    mask = mask.bool()
    median_colors = torch.zeros((rgb_image.size(0), mask.size(
        1), rgb_image.size(1)), device=rgb_image.device)
    for i in range(rgb_image.size(0)):
        for j in range(mask.size(1)):
            for k in range(rgb_image.size(1)):
                valid_pixels = torch.masked_select(rgb_image[i, k], mask[i, j])
                if valid_pixels.numel() > 0:
                    median_value = valid_pixels.median()
                else:
                    median_value = torch.tensor(0.0, device=rgb_image.device)
                median_colors[i, j, k] = median_value
    return median_colors  # / 255.0


def detect(request: TorchFaceFeatureDetectionRequest) -> TorchFaceFeatureDetectionResponse:
    # decode the image
    rospy.loginfo('Decoding')
    frame = msg_to_cv2_img(request.image_raw)

    # 'hair', 'hat', 'glasses', 'face'
    input_image = torch.from_numpy(frame).permute(2, 0, 1).unsqueeze(0).float()
    input_image /= 255.0
    masks_batch_pred, pred_classes = model(input_image)

    thresholds_mask = [
        0.5, 0.75, 0.25, 0.5,  # 0.5, 0.5, 0.5, 0.5,
    ]
    thresholds_pred = [
        0.6, 0.8, 0.1, 0.5,
    ]
    erosion_iterations = 1
    dilation_iterations = 1
    categories = ['hair', 'hat', 'glasses', 'face',]

    masks_batch_pred = binary_erosion_dilation(
        masks_batch_pred, thresholds=thresholds_mask,
        erosion_iterations=erosion_iterations, dilation_iterations=dilation_iterations
    )

    median_colours = (median_color_float(
        input_image, masks_batch_pred).detach().squeeze(0)*255).numpy().astype(np.uint8)

    # discarded: masks = masks_batch_pred.detach().squeeze(0).numpy().astype(np.uint8)
    # discarded: mask_list = [masks[i,:,:] for i in range(masks.shape[0])]

    pred_classes = pred_classes.detach().squeeze(0).numpy()
    class_list = [categories[i] for i in range(
        pred_classes.shape[0]) if pred_classes[i].item() > thresholds_pred[i]]
    colour_list = [median_colours[i, :]
                   for i in range(median_colours.shape[0])]

    response = TorchFaceFeatureDetectionResponse()
    response.detected_features = [
        FeatureWithColour(categories[i], [
            ColourPrediction(colour, distance)
            for colour, distance
            in closest_colours(colour_list[i], RGB_HAIR_COLOURS if categories[i] == 'hair' else RGB_COLOURS)
        ])
        for i
        in range(pred_classes.shape[0])
        if pred_classes[i].item() > thresholds_pred[i]
    ]

    return response


rospy.init_node('torch_service')
rospy.Service('/torch/detect/face_features', TorchFaceFeatureDetection, detect)
rospy.loginfo('Torch service started')
rospy.spin()
